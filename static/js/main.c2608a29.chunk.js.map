{"version":3,"sources":["cwn-onto-3d/onto-state.ts","cwn-onto-3d/data-api.ts","cwn-onto-3d/wsd-view.tsx","cwn-onto-3d/sense-3d-view.tsx","cwn-onto-3d/build-graph.ts","cwn-onto-3d/cwn-onto-3d.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["initState","sentence","tokens","senseClouds","lemmaSenses","selSenseData","reducer","state","action","newState","Object","assign","type","payload","useOntoState","useReducer","ontoState","dispatch","controller","updateSentence","fetch","then","result","json","data","console","log","lemma_senses","clouds","selectSense","senseId","WsdView","props","words","map","x","idx","key","className","endsWith","Sense3dView","useEffect","graphData","V","E","lemmaMap","token","lemma","nid","push","id","label","fx","fy","fz","entries","val","sense","pos","definition","reduce","sum","lemmaNodeId","undefined","length","eid","srcSenseId","senseCloud","relations","headWord","senseDef","source","target","pwn","pwnId","pwn_onto","link_chains","chain","src","edgeLabel","prevPwnId","curPwnId","link_to_base","edgeLable","hypernyms","hyponyms","holonyms","meronyms","G","nodes","values","links","build_graph","graphElem","document","getElementById","graph3D","ForceGraph3D","forceEngine","nodeLabel","nodeAutoColorBy","nodeVal","linkWidth","enableNodeDrag","CwnOnto3D","inputElem","useRef","ref","onKeyDown","ev","placeholder","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.c2608a29.chunk.js","sourcesContent":["import React, { useState, useReducer } from 'react';\r\nimport { WsdToken, SenseClouds, SenseData, LemmaSenses } from \"./data-types\";\r\nimport * as api from './data-api';\r\n\r\ninterface CwnOntoState {\r\n  sentence: string;\r\n  tokens: WsdToken[];\r\n  senseClouds: SenseClouds;\r\n  lemmaSenses: LemmaSenses;\r\n  selSenseData: SenseData;\r\n}\r\n\r\ntype CwnOntoAction =\r\n  COA_NewSentence | COA_NewTokens | \r\n  COA_NewSenseClouds | COA_NewLemmaSenses |\r\n  COA_SelectedSense;\r\n\r\ninterface COA_NewSentence {\r\n  type: \"NEW_SENTENCE\",\r\n  payload: string\r\n}\r\n\r\ninterface COA_NewTokens {\r\n  type: \"NEW_TAGGED\",\r\n  payload: WsdToken[]\r\n}\r\n\r\ninterface COA_NewLemmaSenses {\r\n  type: \"NEW_LEMMA_SENSES\",\r\n  payload: LemmaSenses\r\n}\r\n\r\ninterface COA_NewSenseClouds {\r\n  type: \"NEW_SENSE_CLOUDS\",\r\n  payload: SenseClouds\r\n}\r\n\r\ninterface COA_SelectedSense {\r\n  type: \"SELECT_SENSE\",\r\n  payload: SenseData\r\n}\r\n\r\nfunction initState(){\r\n  return {\r\n    sentence: \"\",\r\n    tokens: [],\r\n    senseClouds: {} as SenseClouds,\r\n    lemmaSenses: {} as LemmaSenses,\r\n    selSenseData: {} as SenseData\r\n  } as CwnOntoState\r\n}\r\n\r\nfunction reducer(state: CwnOntoState, action: CwnOntoAction) {\r\n  let newState = Object.assign({}, state);\r\n  switch (action.type) {\r\n    case 'NEW_SENTENCE':\r\n      newState.sentence = action.payload;\r\n      break;\r\n    case 'NEW_TAGGED':\r\n      newState.tokens = action.payload;\r\n      break;    \r\n    case 'NEW_LEMMA_SENSES':\r\n      newState.lemmaSenses = action.payload;\r\n      break;\r\n    case 'NEW_SENSE_CLOUDS':\r\n      newState.senseClouds = action.payload;\r\n      break;\r\n    case 'SELECT_SENSE':\r\n      newState.selSenseData = action.payload;\r\n      break;\r\n    default:\r\n    // pass\r\n  }\r\n  return newState;\r\n}\r\n\r\nexport interface ontoController {\r\n  updateSentence: (sentence: string) => void,\r\n  selectSense: (senseId: string) => void\r\n}\r\n\r\nexport function useOntoState() {\r\n  let [ontoState, dispatch] = useReducer(reducer, {} as CwnOntoState, initState);\r\n\r\n  function updateSentence(sentence: string) {    \r\n    if(sentence !== ontoState.sentence){\r\n      dispatch({\"type\": \"NEW_SENTENCE\", \"payload\": sentence});\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    api.get_tag(sentence)\r\n      .then((tokens) => {\r\n        console.log(\"tagged\");\r\n        console.log(tokens);\r\n        dispatch({\"type\": \"NEW_TAGGED\", \"payload\": tokens});\r\n        api.get_lemma_senses(tokens)\r\n          .then((lemma_senses) => {\r\n            console.log(\"lemma senses\");\r\n            console.log(lemma_senses);\r\n            dispatch({\"type\": \"NEW_LEMMA_SENSES\", \"payload\": lemma_senses});\r\n          });  \r\n        let wsd = api.get_wsd(tokens);\r\n        return wsd;\r\n      }).then((tokens)=>{\r\n        console.log(\"wsd\");\r\n        console.log(tokens);\r\n        dispatch({\"type\": \"NEW_TAGGED\", \"payload\": tokens});\r\n\r\n        let sense_clouds = api.get_sense_clouds(tokens);        \r\n        return sense_clouds\r\n      }).then((clouds: SenseClouds) => {\r\n        console.log(\"sense clouds\");\r\n        console.log(clouds);\r\n\r\n        dispatch({\"type\": \"NEW_SENSE_CLOUDS\", \"payload\": clouds});\r\n      });\r\n  }\r\n\r\n  function selectSense(senseId: string) {\r\n    api.get_sense_data(senseId)\r\n      .then((data: SenseData)=>{\r\n        console.log(\"sense data\");\r\n        console.log(data);\r\n        dispatch({\"type\": \"SELECT_SENSE\", \"payload\": data});\r\n      })\r\n  }\r\n\r\n  let controller = { updateSentence, selectSense } as ontoController;\r\n  return {ontoState, controller};\r\n}","import { WsdToken, LemmaSenses, SenseClouds, SenseData } from './data-types';\r\n\r\nexport function get_tag(sentence: string): Promise<WsdToken[]> {\r\n  return fetch(\"data/tag.json\")\r\n    .then((result) => result.json())\r\n    .then((result) => {\r\n      let data = result.data;\r\n      let tokens: WsdToken[] = data[0];\r\n      return tokens\r\n    });\r\n}\r\n\r\nexport function get_wsd(taggedList: WsdToken[]): Promise<WsdToken[]> {\r\n  return fetch(\"data/wsd.json\")\r\n    .then((result) => result.json())\r\n    .then((result) => {\r\n      let data = result.data;\r\n      let tokens: WsdToken[] = data[0];\r\n      return tokens\r\n    });\r\n}\r\n\r\nexport function get_lemma_senses(taggedList: WsdToken[]): Promise<LemmaSenses> {\r\n  return fetch(\"data/lemmas.json\")\r\n    .then((result) => result.json())\r\n    .then((result) => {\r\n      let data = result.data;\r\n      return data as LemmaSenses;\r\n    });\r\n}\r\n\r\nexport function get_sense_clouds(taggedList: WsdToken[]): Promise<SenseClouds> {\r\n  return fetch(\"data/sense_clouds.json\")\r\n    .then((result) => result.json())\r\n    .then((result) => {\r\n      let data = result.data;\r\n      return data as SenseClouds;\r\n    });\r\n}\r\n\r\nexport function get_sense_data(senseId: string): Promise<SenseData> {\r\n  return fetch(\"data/sense_data.json\")\r\n    .then((result) => result.json())\r\n    .then((result) => {\r\n      let data = result.data;\r\n      return data as SenseData;\r\n    });\r\n}","import React from 'react';\r\nimport { WsdToken } from './data-types';\r\nimport \"./wsd-token.css\"\r\n\r\nexport interface WsdViewProps {\r\n  tokens: WsdToken[]\r\n}\r\n\r\nexport function WsdView(props: WsdViewProps) {\r\n  console.log(\"WsdView\")\r\n  console.log(props);\r\n  let words = props.tokens.map((x: WsdToken, idx: number) => {\r\n    return (\r\n      <div key={`token-${x[0]}-${idx}`} className=\"token-wrapper\">\r\n        <div className=\"pos\">\r\n          {x[1].endsWith(\"CATEGORY\")? \"\": x[1]}\r\n        </div>\r\n        <div className=\"word\">{x[0]}</div>        \r\n        <div className=\"badge badge-info sense-def\">{x[3]}</div>\r\n      </div>)\r\n  });\r\n\r\n  return (\r\n    <div className=\"d-flex flex-wrap\">\r\n      {words}\r\n    </div>\r\n  )\r\n}","import React, { useEffect } from 'react';\r\nimport { LemmaSense, LemmaSenses, SenseClouds, WsdToken } from './data-types';\r\nimport { build_graph, INode } from './build-graph';\r\nimport ForceGraph3D from '3d-force-graph';\r\n\r\nexport interface Sense3dViewProps {\r\n  tokens: WsdToken[];\r\n  lemmaSenses: LemmaSenses;\r\n  senseClouds: SenseClouds;    \r\n}\r\n\r\nexport function Sense3dView(props: Sense3dViewProps){\r\n  useEffect(()=>{\r\n    console.log(\"sense 3d view\");\r\n    let graphData = build_graph(props.tokens, props.lemmaSenses, props.senseClouds);\r\n    let graphElem = document.getElementById(\"3d-graph\");\r\n    if(graphElem !== null){\r\n      let graph3D = ForceGraph3D()(graphElem);\r\n      let engine = graph3D.forceEngine();\r\n      graph3D.graphData(graphData)\r\n        .nodeLabel(\"label\")\r\n        .nodeAutoColorBy(\"type\")\r\n        .nodeVal((x)=>{\r\n          let node = x as INode;\r\n          if(node.type == \"Lemma\") return 20;\r\n          else return 3;\r\n        })\r\n        .linkWidth(10)\r\n        .enableNodeDrag(true);\r\n    }\r\n  }, [props.lemmaSenses, props.senseClouds])\r\n  return (\r\n    <div id=\"3d-graph\"></div>\r\n  )\r\n}","import { LemmaSense, SenseClouds, LemmaSenses, WsdToken } from \"./data-types\";\r\n\r\nexport interface OntoGraph {\r\n  nodes: INode[];\r\n  links: IEdge[];\r\n}\r\n\r\nexport interface INode {\r\n  id: string;\r\n  type: \"Lemma\" | \"CwnSense\" | \"PwnSynset\" |\r\n        \"HyperHypo\" | \"HoloMero\";        \r\n  label: string;\r\n  fx?: number;\r\n  fy?: number;\r\n  fz?: number;\r\n}\r\n\r\nexport interface IEdge {\r\n  source: string;\r\n  target: string;\r\n  label: string;\r\n}\r\n\r\nexport function build_graph(tokens: WsdToken[], lemmaSenses: LemmaSenses, senseClouds: SenseClouds) {\r\n  let V = {} as { [nid: string]: INode };\r\n  let E = {} as { [eid: string]: IEdge };;\r\n  \r\n  const PWN_LEVEL_0 = -100;\r\n  const PWN_LEVEL_1 = -200;\r\n  let lemmaMap: {[lemma: string]: string[]} = {};\r\n  tokens.map((token, idx)=>{\r\n    let lemma = token[0];\r\n    let nid = `${lemma}-${idx}`;\r\n    \r\n    if (lemma in lemmaMap){\r\n      lemmaMap[lemma].push(nid);\r\n    } else {\r\n      lemmaMap[lemma] = [nid];\r\n    }\r\n    \r\n    V[nid] = {\r\n      id: nid, type: \"Lemma\", label: lemma,\r\n      fx: idx * 100, fy: 0, fz: 0\r\n    } as INode;\r\n  });\r\n\r\n  Object.entries(lemmaSenses)\r\n    .map((val, idx) => {\r\n      let [lemma, senses] = val;\r\n      \r\n      senses.map((sense: LemmaSense) => {\r\n        V[sense.id] = {\r\n          id: sense.id,\r\n          type: \"CwnSense\",\r\n          label: `(${sense.pos}) ${sense.definition}`,\r\n          fx: lemmaMap[lemma].reduce((sum, lemmaNodeId)=>{\r\n            sum += V[lemmaNodeId].fx !== undefined ? V[lemmaNodeId].fx!: 0;\r\n            return sum;\r\n          }, 0) / lemmaMap[lemma].length\r\n        }\r\n\r\n        lemmaMap[lemma].map((lemmaNodeId)=>{\r\n          let eid = `${lemmaNodeId}-${sense.id}`;\r\n          E[eid] = {\r\n            \"source\": lemmaNodeId,\r\n            \"target\": sense.id,\r\n            \"label\": \"hasSense\"\r\n          };\r\n        });\r\n      })\r\n\r\n    });\r\n\r\n  Object.entries(senseClouds)\r\n    .map((val, idx) => {\r\n      let [srcSenseId, senseCloud] = val;\r\n\r\n      senseCloud.relations.map((sense) => {\r\n        let [relType, senseId, headWord, pos, senseDef] = sense;\r\n        if (!(senseId in V)) {\r\n          V[senseId] = {\r\n            id: senseId, type: \"CwnSense\", label: `[${headWord}] (${pos}) ${senseDef}`\r\n          }\r\n        }\r\n\r\n        let eid = `${srcSenseId}-${senseId}`;\r\n        E[eid] = {\r\n          source: srcSenseId, target: senseId, label: \"CwnRelation\"\r\n        }\r\n      });\r\n\r\n      // build PWN synset link\r\n      let [_, pwnId] = senseCloud.pwn;\r\n      if (!(pwnId in V)) {\r\n        V[pwnId] = {\r\n          id: pwnId, type: \"PwnSynset\", label: pwnId,\r\n          fy: PWN_LEVEL_0\r\n        }\r\n      }\r\n\r\n      let eid = `${srcSenseId}-${pwnId}`;\r\n      E[eid] = {\r\n        source: srcSenseId, target: pwnId, label: \"PwnMapping\"\r\n      }\r\n\r\n      // build PWN synset relations\r\n      // link hypernyms\r\n      let pwn_onto = senseCloud.pwn_onto;\r\n\r\n      let link_chains = (chain: string[] | undefined, src: string, edgeLabel: string) => {\r\n        if (chain === undefined) {\r\n          return;\r\n        }\r\n\r\n        chain.reduce((prevPwnId, curPwnId) => {\r\n          if (!(curPwnId in V)) {\r\n            V[curPwnId] = {\r\n              id: curPwnId, type: \"HyperHypo\", label: curPwnId,\r\n              fy: PWN_LEVEL_1\r\n            }\r\n          }\r\n\r\n          let eid = `${prevPwnId}-${curPwnId}`;\r\n          E[eid] = {\r\n            source: prevPwnId, target: curPwnId, label: edgeLabel\r\n          }\r\n          return curPwnId;\r\n        }, src);\r\n      }\r\n\r\n      let link_to_base = (chain: string[] | undefined, src: string, edgeLable: string) => {\r\n        if (chain === undefined) {\r\n          return;\r\n        }\r\n\r\n        chain.map((curPwnId) => {\r\n          if (!(curPwnId in V)) {\r\n            V[curPwnId] = {\r\n              id: curPwnId, type: \"HoloMero\", label: curPwnId,\r\n              fy: PWN_LEVEL_1\r\n            }\r\n          }\r\n\r\n          let eid = `${src}-${curPwnId}`;\r\n          E[eid] = {\r\n            source: src, target: curPwnId, label: edgeLable\r\n          }\r\n        });\r\n      }\r\n\r\n      link_chains(pwn_onto.hypernyms, pwnId, \"hypernymy\");\r\n      link_chains(pwn_onto.hyponyms, pwnId, \"hyponymy\");\r\n      link_to_base(pwn_onto.holonyms, pwnId, \"holonymy\");\r\n      link_to_base(pwn_onto.meronyms, pwnId, \"meronymy\");\r\n\r\n    });\r\n\r\n  let G = { nodes: Object.values(V), links: Object.values(E) } as OntoGraph;\r\n  console.log(G);\r\n  return G\r\n}","import React, { useRef } from 'react';\r\nimport \"./cwn-onto-3d.css\"\r\nimport { useOntoState } from './onto-state';\r\nimport { WsdView } from './wsd-view';\r\nimport { Sense3dView } from './sense-3d-view';\r\n\r\nexport function CwnOnto3D() {\r\n  let { ontoState, controller } = useOntoState();\r\n  let inputElem = useRef(null);\r\n\r\n  let onInputKeyDown = (ev: React.KeyboardEvent) => {\r\n    if (ev.key === \"Enter\") {\r\n      console.log(\"enter\");\r\n      controller.updateSentence(\"<default>\");\r\n    }\r\n  }\r\n\r\n  // controller.selectSense(\"\");\r\n  return (\r\n    <div>\r\n      <input\r\n        ref={inputElem}\r\n        id=\"inputText\" type=\"text\"\r\n        onKeyDown={onInputKeyDown}\r\n        placeholder=\"輸入句子\"></input>\r\n      <div className=\"cwn-onto-3d\">\r\n        <WsdView tokens={ontoState.tokens}/>\r\n        <Sense3dView \r\n          tokens={ontoState.tokens}\r\n          lemmaSenses={ontoState.lemmaSenses}\r\n          senseClouds={ontoState.senseClouds}/>\r\n      </div>\r\n    </div>\r\n  )\r\n}","import React from 'react';\nimport './App.css';\nimport { CwnOnto3D } from './cwn-onto-3d';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <CwnOnto3D></CwnOnto3D>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}